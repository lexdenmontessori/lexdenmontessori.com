// Generated by CoffeeScript 1.4.0
(function() {
  var assert, date, vows;

  assert = require('assert');

  vows = require('vows');

  date = require('../lib/date');

  vows.describe('dates').addBatch({
    'from equal years': {
      topic: function() {
        return [new Date('2010'), new Date('2010')];
      },
      "are equal": function(a) {
        return assert.ok(date.datesEqual(a[0], a[1]));
      }
    },
    'from different years': {
      topic: function() {
        return [new Date('2010'), new Date('2011')];
      },
      "are different": function(a) {
        return assert.notEqual(date.datesEqual(a[0], a[1]), true);
      }
    },
    'with equal year, month, day': {
      topic: function() {
        return [new Date('2010-05-13'), new Date('2010-05-13')];
      },
      "are equal": function(a) {
        return assert.ok(date.datesEqual(a[0], a[1]));
      }
    }
  })["export"](module);

  vows.describe('weekday').addBatch({
    "Mondays": {
      topic: function() {
        return new Date("2011-May-23");
      },
      "are day 0": function(m) {
        return assert.equal(date.weekday(m), 0);
      }
    },
    "Sundays": {
      topic: function() {
        return new Date("2011-May-29");
      },
      "are day 6": function(s) {
        return assert.equal(date.weekday(s), 6);
      }
    }
  })["export"](module);

  vows.describe('weekends').addBatch({
    'Saturdays': {
      topic: function() {
        return new Date('2011-May-28');
      },
      "are in the weekend": function(d) {
        return assert.ok(date.weekend(d));
      }
    },
    "Fridays": {
      topic: function() {
        return new Date('1991-05-31');
      },
      "are not in the weekend": function(d) {
        return assert.ok(!date.weekend(d));
      }
    },
    "Mondays": {
      topic: function() {
        return new Date("1975-10-27");
      },
      "are not in the weekend": function(d) {
        return assert.ok(!date.weekend(d));
      }
    }
  })["export"](module);

  vows.describe("bankHolidays").addBatch({
    "bank holiday": {
      topic: function() {
        return new Date("2010-01-01");
      },
      "is bank holiday": function(hol) {
        return assert.ok(date.isBankHoliday(hol));
      }
    },
    "non-bank holiday in weekdays": {
      topic: function() {
        return new Date("2011-06-10");
      },
      "is not bank holiday": function(nonHol) {
        return assert.ok(!date.isBankHoliday(nonHol));
      }
    },
    "non-bank holiday in weekend": {
      topic: function() {
        return new Date("2011-06-11");
      },
      "is not bank holiday": function(nonHol) {
        return assert.ok(!date.isBankHoliday(nonHol));
      }
    }
  })["export"](module);

  vows.describe("payableDate").addBatch({
    "non-bank holiday weekday": {
      topic: function() {
        return new Date("2011-06-10");
      },
      "is payable": function(d) {
        return assert.ok(date.payableDate(d));
      }
    }
  })["export"](module);

  vows.describe("latestPayableDate").addBatch({
    "non-bank holiday weekday not Monday": {
      topic: function() {
        return new Date("2011-06-10");
      },
      "payable today": function(d) {
        return assert.deepEqual(new Date("2011-06-10"), date.latestPayableDate(d));
      }
    },
    "non-bank holiday Monday": {
      topic: function() {
        return new Date("2011-06-06");
      },
      "payable today": function(d) {
        return assert.deepEqual(new Date("2011-06-06"), date.latestPayableDate(d));
      }
    },
    "bank holiday Monday, non-bank-holiday previous Friday": {
      topic: function() {
        return new Date("2011-08-29");
      },
      "payable previous Friday": function(d) {
        return assert.deepEqual(new Date("2011-08-26"), date.latestPayableDate(d));
      }
    },
    "bank holiday Monday, bank holiday previous Friday, non-bank-holiday previous Thursday": {
      topic: function() {
        return new Date("2011-05-02");
      },
      "payable previous Thursday": function(d) {
        return assert.deepEqual(new Date("2011-04-28"), date.latestPayableDate(d));
      }
    },
    "Saturday, non-bank holiday previous Friday": {
      topic: function() {
        return new Date("2011-06-11");
      },
      "payable previous Friday": function(d) {
        return assert.deepEqual(new Date("2011-06-10"), date.latestPayableDate(d));
      }
    }
  })["export"](module);

  vows.describe("distributeMonthly").addBatch({
    "one month, start payable": {
      topic: function() {
        return new Date("2011-06-10");
      },
      "is same date": function(d) {
        return assert.deepEqual([new Date("2011-06-10")], date.distributeMonthly(d, 1));
      }
    },
    "two months, start non-payable": {
      topic: function() {
        return new Date("2011-08-29");
      },
      "is previous payable, then next month irrespective of decrementing start date": function(d) {
        return assert.deepEqual([new Date("2011-08-26"), new Date("2011-09-29")], date.distributeMonthly(d, 2));
      }
    }
  })["export"](module);

  vows.describe('Intervals').addBatch({
    "with positional arguments": {
      topic: function() {
        return new date.Interval(new Date('2010-05-13'), new Date('2010-09-23'));
      },
      "has correct start": function(d) {
        return assert.ok(date.datesEqual(d.start, new Date("2010-05-13")));
      },
      "has correct end": function(d) {
        return assert.ok(date.datesEqual(d.end, new Date("2010-09-23")));
      }
    },
    "with string arguments": {
      topic: function() {
        return new date.Interval('2010-05-13', '2010-09-23');
      },
      "has correct start": function(d) {
        return assert.ok(date.datesEqual(d.start, new Date("2010-05-13")));
      },
      "has correct end": function(d) {
        return assert.ok(date.datesEqual(d.end, new Date("2010-09-23")));
      }
    },
    "with single Date argument": {
      topic: function() {
        return new date.Interval(new Date('2010-05-13'));
      },
      "has correct start": function(d) {
        return assert.ok(date.datesEqual(d.start, new Date("2010-05-13")));
      },
      "has correct end": function(d) {
        return assert.ok(date.datesEqual(d.end, new Date("2010-05-13")));
      }
    },
    "with single string argument": {
      topic: function() {
        return new date.Interval('2010-05-13');
      },
      "has correct start": function(d) {
        return assert.ok(date.datesEqual(d.start, new Date("2010-05-13")));
      },
      "has correct end": function(d) {
        return assert.ok(date.datesEqual(d.end, new Date("2010-05-13")));
      }
    },
    "with object argument": {
      topic: function() {
        return new date.Interval({
          start: "2010-05-13",
          end: "2010-09-23"
        });
      },
      "has correct start": function(d) {
        return assert.ok(date.datesEqual(d.start, new Date("2010-05-13")));
      },
      "has correct end": function(d) {
        return assert.ok(date.datesEqual(d.end, new Date("2010-09-23")));
      }
    },
    'with equal year': {
      topic: function() {
        return new date.Interval(new Date('2010-05-13'), new Date('2010-09-23'));
      },
      "have no year range": function(a) {
        return assert.deepEqual(a.years(), 0);
      },
      "toString": function(a) {
        return assert.deepEqual(a.toString(), "13 Mayâ€“23 Sep.");
      }
    },
    'with equal year, month, day': {
      topic: function() {
        return new date.Interval(new Date('2010-05-13'), new Date('2010-05-13'));
      },
      "have no range": function(a) {
        return assert.deepEqual(a.ymd(), {
          years: 0,
          months: 0,
          days: 0
        });
      },
      "contain only that day": function(i) {
        return assert.ok(i.contains(new Date("2010-05-13")));
      },
      "have only that day in enumeration": function(i) {
        return assert.deepEqual(i.enumerate(), [new Date("2010-05-13")]);
      },
      "toString": function(a) {
        return assert.deepEqual(a.toString(), "13 May");
      }
    },
    'with one day difference in same month': {
      topic: function() {
        return new date.Interval(new Date('2010-05-13'), new Date('2010-05-14'));
      },
      "have range of one day": function(a) {
        return assert.deepEqual(a.ymd(), {
          years: 0,
          months: 0,
          days: 1
        });
      },
      "contain start day": function(i) {
        return assert.ok(i.contains(new Date("2010-05-13")));
      },
      "contain end day": function(i) {
        return assert.ok(i.contains(new Date("2010-05-14")));
      },
      "do not contain days before start": function(i) {
        return assert.ok(!i.contains(new Date("2010-05-12")));
      },
      "do not contain days after end": function(i) {
        return assert.ok(!i.contains(new Date("2010-05-15")));
      },
      "have both days in enumeration": function(i) {
        return assert.deepEqual(i.enumerate(), [new Date('2010-05-13'), new Date('2010-05-14')]);
      }
    },
    "with one day difference from one month to next": {
      topic: function() {
        return new date.Interval(new Date('2011-05-31'), new Date('2011-06-01'));
      },
      "have range of one day": function(a) {
        return assert.deepEqual(a.ymd(), {
          years: 0,
          months: 0,
          days: 1
        });
      },
      "have both days in enumeration": function(i) {
        return assert.deepEqual(i.enumerate(), [new Date('2011-05-31'), new Date('2011-06-01')]);
      }
    },
    "with one day difference from one year to next": {
      topic: function() {
        return new date.Interval(new Date('2011-12-31'), new Date('2012-01-01'));
      },
      "have range of one day": function(a) {
        return assert.deepEqual(a.ymd(), {
          years: 0,
          months: 0,
          days: 1
        });
      },
      "have both days in enumeration": function(i) {
        return assert.deepEqual(i.enumerate(), [new Date('2011-12-31'), new Date('2012-01-01')]);
      }
    },
    "with one month difference in same year": {
      topic: function() {
        return new date.Interval(new Date('2010-05-26'), new Date('2010-06-26'));
      },
      "have range of one month": function(a) {
        return assert.deepEqual(a.ymd(), {
          years: 0,
          months: 1,
          days: 0
        });
      },
      "contain dates in between start and end": function(i) {
        return assert.ok(i.contains(new Date("2010-05-29")));
      }
    },
    "with one month difference in different year": {
      topic: function() {
        return new date.Interval(new Date('2010-12-26'), new Date('2011-01-26'));
      },
      "have range of one month": function(a) {
        return assert.deepEqual(a.ymd(), {
          years: 0,
          months: 1,
          days: 0
        });
      }
    },
    "with one year difference": {
      topic: function() {
        return new date.Interval(new Date('2010-12-26'), new Date('2011-12-26'));
      },
      "have range of one year": function(a) {
        return assert.deepEqual(a.ymd(), {
          years: 1,
          months: 0,
          days: 0
        });
      }
    },
    "with arbitrary dates": {
      topic: function() {
        return new date.Interval(new Date('2010-05-26'), new Date('2012-03-29'));
      },
      "have correct range": function(a) {
        return assert.deepEqual(a.ymd(), {
          years: 1,
          months: 10,
          days: 3
        });
      }
    },
    "in reverse order": {
      topic: function() {
        return new date.Interval(new Date('2012-03-29'), new Date('2010-05-26'));
      },
      "have zero range": function(a) {
        return assert.deepEqual(a.ymd(), {
          years: 0,
          months: 0,
          days: 0
        });
      },
      "do not contain dates 'between' start and end": function(i) {
        return assert.ok(!i.contains(new Date("2011-06-05")));
      },
      "have no days in enumeration": function(i) {
        return assert.deepEqual(i.enumerate(), []);
      }
    }
  })["export"](module);

  vows.describe("DaySet").addBatch({
    "one day no holes": {
      topic: function() {
        return new date.DaySet(["2011-05-28", "2011-05-28"], []);
      },
      "contains that day": function(d) {
        return assert.ok(d.contains("2011-05-28"));
      },
      "has that day in enumeration": function(i) {
        return assert.deepEqual(i.enumerate(), [new Date("2011-05-28")]);
      }
    },
    "one day, one hole is that day": {
      topic: function() {
        return new date.DaySet(["2011-05-28", "2011-05-28"], [["2011-05-28", "2011-05-28"]]);
      },
      "does not contain that day": function(d) {
        return assert.ok(!d.contains("2011-05-28"));
      },
      "has no days in enumeration": function(i) {
        return assert.deepEqual(i.enumerate(), []);
      }
    },
    "one week": {
      topic: function() {
        return new date.DaySet(["2011-05-23", "2011-05-29"], []);
      },
      "contains start": function(d) {
        return assert.ok(d.contains("2011-05-23"));
      },
      "contains end": function(d) {
        return assert.ok(d.contains("2011-05-29"));
      },
      "contains a day in the middle": function(d) {
        return assert.ok(d.contains("2011-05-25"));
      },
      "has those days in enumeration": function(i) {
        return assert.deepEqual(i.enumerate(), [new Date("2011-05-23"), new Date("2011-05-24"), new Date("2011-05-25"), new Date("2011-05-26"), new Date("2011-05-27"), new Date("2011-05-28"), new Date("2011-05-29")]);
      }
    },
    "one week with weekend hole": {
      topic: function() {
        return new date.DaySet(["2011-05-23", "2011-05-29"], [["2011-05-28", "2011-05-29"]]);
      },
      "contains weekday": function(d) {
        return assert.ok(d.contains("2011-05-25"));
      },
      "does not contain Satuday": function(d) {
        return assert.ok(!d.contains("2011-05-28"));
      },
      "has weekdays in enumeration": function(i) {
        return assert.deepEqual(i.enumerate(), [new Date("2011-05-23"), new Date("2011-05-24"), new Date("2011-05-25"), new Date("2011-05-26"), new Date("2011-05-27")]);
      }
    }
  })["export"](module);

}).call(this);
